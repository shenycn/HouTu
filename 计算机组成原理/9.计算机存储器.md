# 计算机存储器
## 1、存储器的分类
**按照存储介质**分为半导体存储器（内存，U盘，固态硬盘）、磁存储器（磁带，磁盘）

**按照存取方式**分为随机存储器RAM（可以随机读取，与存取的位置无关）、串行存储器（与位置有关，按顺序查找）、只读存储器ROM（只读不写）
## 2、存储器的层次结构
存储器要考虑的三个因素：**读写速度、存储容量、价格**
使用位价客观描述存储器的性价比
容量+价格=>位价：每比特位价格
依据位价和读写速度将存储器分为`缓存`(CPU里的寄存器和高速缓存)，`主存`（计算机内存），`辅存`（计算机外部存储U盘等）三个层次
![图示](https://img-blog.csdnimg.cn/2020020219103832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmtjbg==,size_16,color_FFFFFF,t_70)
图片来源：慕课网实战课程《编程必备基础 计算机组成原理+操作系统+计算机网络》

**缓存-主存层次**
原理：局部性原理
实现：在CPU与主存之间增加一层速度快（容量小）的Cache（高速缓存）
目的：解决主存速度不足的问题

**局部性原理**
CPU访问存储器时，无论是存取指令还是存取数据，所访问存储单元都趋于聚集在一个较小的连续区域中。

**主存-辅存层次**
原理：局部性原理
实现：在主存之外增加辅助存储器
目的：解决主存容量不够的问题

## 3、主存储器-内存
**为什么主存因为断电会丢失数据？**
RAM通过电容来存储数据，必须每隔一段时间时间刷新一次，如果断电，隔一段时间后将会丢失所有数据

**主存储器与CPU如何交互？**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200203103704100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmtjbg==,size_16,color_FFFFFF,t_70)
图片来源：慕课网实战课程《编程必备基础 计算机组成原理+操作系统+计算机网络》

**操作系统位数与主存的关系**
32位：2<sup>32</sup> =4x2<sup>20</sup> =4GB   (地址总线32位，寻址范围4GB大小)
64位：2<sup>64</sup> =2<sup>34</sup> x2<sup>30</sup> =2<sup>34</sup> GB (地址总线64位，寻址范围2<sup>34</sup> GB大小)

## 4、辅助存储器-磁盘
**磁盘的物理结构**
* 表面是可磁化的硬磁特性材料
* 通过磁头的径向运动读取磁道信息

**磁盘的调度算法**
1. 先来先服务算法
对于多个读写磁盘的请求都会将它排成一个队，谁先来读写谁
2. 最短寻道时间优先算法
调度的顺序与磁头当前的位置有关
会优先访问距离磁头最近的磁道
每次读取找到当前磁道最近的磁道读取
3. 扫描算法（电梯算法）
磁头每次只往一个方向运动
到达一个方向需要服务的尽头再反方向运动
4. 循环扫描算法
在扫描算法的基础上
只往一个方向读取，由内而外或者由外而内

## 5、计算机的高速缓存
高速缓存位于缓存-主存层次，在CPU与主存中间
目的是为了解决CPU与主存速度不匹配的问题

**主存内部存储结构**
`字`：存放在一个存储单元当中二进制代码的组合，可以表示一个数据，一个指令，一个字符串，是内存当中存储单元的最小单位
`字块`：连续的字，一组字；存储在连续的存储单元中而被看作是一个单元的一组字

**主存关于字，字块的简单运算**
一个字有32位，一个字块共B个字，主存共M个字块，B x M=主存总字数，B x M x 32=主存总容量（bits）

**字的寻址，字的地址包括两个部分**
字块的部分用来指示当前的需要寻找的字属于哪个字块（字属于哪个字块）
字的部分用来寻找字块里面哪一个字是地址所指定的字（地址指定的字是字块中的哪个字）
前m位指定字块的地址  2<sup>m</sup>  = M（主存共M个字块）
后b位指定字在字块中的地址 2<sup>b</sup> = B（一个字块B个字）

**主存存储数据的方法计算例子**
`假设主存用户容量为4G，字块大小为4M，字长为32位，则对于字地址中的块地址m和块内地址b的位数，至少应该是多少？`
4G=4096M
字块数：4096/4 = 1024 
字块地址m：log<sub>2</sub><sup>1024</sup> = 10  （在地址里至少需要10位来表示1024个字块）
块内字数：4M/32bit = 1048576 （每一个字块里有这么多字）
块内地址b：log<sub>2</sub><sup>1048576</sup> = 20 （至少需要20位块内地址来表示块内所有的字）
m>=10，b>=20

**高速缓存内部存储结构与主存非常类似**
缓存的运算与主存运算类似
主存容量 >（远大于）缓存容量
缓存里存储的数据其实是主存里数据的一个备份，缓存每一个数据来自主存
1. 存储的逻辑结构类似
2. 缓存的容量较小
3. 缓存的速度更快

**高速缓存的工作原理**
CPU需要的数据在缓存里，CPU可以高速的拿到数据
需要数据不再缓存里，CPU需要去主存里拿
CPU需要尽可能的从高速缓存中取数据，用量化的指标`命中率`来量化CPU从高速缓存取数据成功的几率
`命中率是衡量缓存的重要性指标`
`理论上CPU每次都能从高速缓存取数据的时候，命中率为1`高速缓存容量不及主存，命中率永远不可能为1

命中率如何计算？
假设访问主存次数：N<sub>m</sub>
访问高速缓存次数：N<sub>c</sub>
命中率： h = N<sub>c</sub>/(N<sub>c</sub>+N<sub>m</sub>) （缓存次数占总次数比）

访问效率：e
假设访问主存时间：t<sub>m</sub>
访问缓存时间：t<sub>c</sub>
访问Cache-主存系统平均时间：t<sub>a</sub> = ht<sub>c</sub>+(1-h)t<sub>m</sub>
访问效率：e = t<sub>c</sub>/t<sub>a</sub>（缓存时间/平均时间）

**高速缓存的替换策略**
良好的策略使得缓存里的数据都为CPU所用
`高速缓存的替换时机`：当CPU所需要的数据不再Cache内时，需要从主存里载入所需要的数据
1. 随机算法
每一次发生替换时随机选取高速缓存中的一个位置
2. 先进先出算法（FIFO）
把Cache看作是一个先进先出的队列
优先替换掉最先进入队列里的字块
3. 最不经常使用算法（LFU）
优先淘汰最不经常使用的字块
需要额外的空间去记录字块的使用频率
4. 最近最少使用算法（LRU）
优先淘汰一段时间内没有使用的字块
有多种实现方法，一般使用双向链表
把当前访问节点置于链表前面（保证链表头部节点是最近使用的）
淘汰的时候淘汰链表尾部的节点
![最近最少使用算法图示](https://img-blog.csdnimg.cn/20200204233808969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmtjbg==,size_16,color_FFFFFF,t_70)
图片来源：慕课网实战课程《编程必备基础 计算机组成原理+操作系统+计算机网络》