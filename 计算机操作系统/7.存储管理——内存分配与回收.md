在早期的计算机编程并不需要过多的存储管理，但是随着计算机越来越复杂，存储管理成为必要。

**存储管理主要解决三个问题：**
1. 确保计算机有足够的内存处理数据
2. 确保程序可以从一段可用内存里面获取一部分内存进行使用
3. 确保程序可以归还使用后的内存提供给其他程序使用

# 内存分配的过程
 内存分配的有三个方法
## 1. 单一连续分配
是最简单的内存分配方式，只能在单用户、单进程的操作系统中使用，分配的过程就是把内存分成系统区和用户区，系统区所有内存都给操作系统使用，用户区所有内存都给用户区的程序使用。这一方法已经过时了。

## 2.固定分区分配
是支持多道程序的最简单的存储分配方式，把内存空间划分成若干个固定大小的区域，每个分区只提供给一个程序使用，互不干扰

## 3. 动态分区分配
 是操作系统里比较常用的分配方法，按照进程的实际需要，动态的分配进程所需要的内存空间，涉及到相关的数据结构和分配的具体算法

**所涉及的数据结构**

`1, 动态分区空闲表数据结构`
假设主存里面由若干个分区，并且有一些分区是已经使用的，另外的一些分区没有使用。需要一个数据结构存储去存储某一个分区是否已经被使用。
| 分区 | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 标记 | 0    | 1    | 0    | 0    | 0    | 1    | 0    | 1    | 0    | 1    |
上面是一张空闲表数据结构，如果是0表示没有被使用，1表示已经被使用了。

`2.动态分区空闲链数据结构`
使用双向链表来保存动态分区里的空闲区域，把所有的空闲节点首尾相连形成一个空闲的链表。
比如有如下一个表的分区：
|空闲区1|非空闲|空闲区2|空闲去3|非空闲|非空闲|空闲区4|
-|-|-|-|-|-|-
把空闲区域首尾相连得到空闲链：
节点1<=>节点2<=>节点3<=>节点4，如表中空闲区2和空闲区3是连续的，可以把他们的节点合并起来节点1<=>节点2-3<=>节点4，节省空闲链表的节点，因为节点的大小不一样，所以需要在每个节点里面记录它可以存储的容量

**动态分区分配的三个算法**
`1.首次适应算法（FF算法）`
每次需要进行内存分配的时候都是从开始的顺序去查找适合的内存去，在这里主要是用空闲链表的数据结构，如果遍历整个链表没有合适的空闲区，则表示这次分配失败，如果找到了空闲区，就把这个空闲区分配给进程使用。
这一算法存在一个问题，每一次分配都是从头部开始，导致头部的地址空间不断的被划分，头部地址被分配很多次之后，空间就会很小，很多碎片每次分配的时候都需要遍历直到快到尾部的时候才获得相应的内存。
在FF算法后提出的改进算法，循环适应算法，每一次分配不是从头部开始，而是从上一次检索结束的位置开始。

`2.最佳适应算法（FB算法）`
需要把空闲链表按照容量的大小进行排序，在每一次需要分配的时候遍历整个空闲去链表直到找到最佳的空闲区。
可以避免一些大材小用的情况，因为空闲链表从小到大遍历，因此所匹配的第一个空闲区一定是容量最小最合适的区域。

`3.快速适应算法（QF算法）`
需要多个空闲链表，每一个链表都存储一种容量的空闲区，即容量为1的空闲区保存为一个链表，容量为2的空闲区保存为一个链表。
在进行内存分配的时候就可以快速找到适合的内存分配的区域。

# 内存回收的过程
**可能会出现四种情况**
`1.需要回收的区域与空闲区连接在一起并且位于空闲区的后面`
使用空闲链表数据结构保存空闲区，不需要新建新的链表节点，只需要把空闲区的容量增大到包括回收区的容量

`2.与上面情况一样，但位于空闲区的前面`
需要将回收区和空闲区合并起来成为一个新的节点成为新的空闲区，把新的空闲区使用回收区的地址作为新节点的地址

`3.回收区位于两块空闲区之间`
需要合并回收区与他前面连接和后面连接的空闲区成为新空闲区，然后使新空闲区使用原本回收区前面的空闲区的地址。
假设区域顺序为空闲区1，回收区，空闲区2，那么应该合并这三个区域使用空闲区1的地址

`4.单一的回收区没有连接任何的回收区`
只需要为回收区创建新的空闲区节点，然后把这一节点插入到相应的空闲链表里面