 # 什么是死锁
 引用百度百科对死锁严格的定义
 >死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

假设有一个十字路口，有四辆汽车分别从东南西北四个方向相对向前形式，他们会在十字路口堵塞，如果四辆汽车相互之间没有退让，就会形成死锁 ，它们永远无法开出十字路口。
哲学家进餐模型最极端的情况，五个哲学家同时拿起左边的筷子等待进餐，他们都无法获得右筷子的释放最终全部饿死，这也是死锁。

## 死锁是如何产生的
**1.相互竞争资源**
共享资源数量无法满足进程的需求，即资源不够的情况下就会出现竞争资源，因此各个进程之间就会因为共享资源的竞争从而导致死锁。
假设有两个进程，进程1需要使用传真机并获取到了资源， 进程2需要获取打印机并且也获取到了资源， 如果此时进程1还需要获取打印机，进程2也需要获取传真机，他们就无法获取，都在等待请求的资源被释放，但是它们自身占用的资源又不会被释放。 如果此时系统里多一个打印机多一个传真机都不会导致死锁的产生，这一问题的本质源于资源不够。

**2.进程调度顺序不当**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200831044851529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmtjbg==,size_16,color_FFFFFF,t_70#pic_center)
图片来源：慕课网
还是上述的例子，假设进程1申请传真机为步骤A，进程2申请打印机为步骤B，进程2申请传真机为步骤C，进程1申请打印机为步骤D。 按照哦A->B->C->D的顺序就会造成死锁的产生。 如果顺序为A->D->B->C，或者B->C->A->D都不会产生死锁的情况。

## 死锁的四个必要条件
如果是死锁一定满足下面四个条件，只满足一个或者两个都不会造成死锁
 **1.互斥条件**
 进程对资源的使用是`排他性的使用`，也就是说资源只能由一个进程使用，其他进程需要使用只能等待资源被释放

 **2.请求保持条件**
 进程至少保持一个资源，并且又提出了新的资源请求，这是新的资源被占用，因此进程的这一请求被阻塞，同时被阻塞的进程又不释放自己保持的资源。 

 **3.不可剥夺条件**
 进程获得的资源在没有使用的时候，任何别的程序包括操作系统 都不能把 资源成这个进程里剥夺出来 ，获得的资源只能由进程自身释放。 

 **4.环路等待条件** 
 发生死锁的时候，必然存在进程-资源的环形等待链。

# 死锁应该如何处理
 ## 预防死锁的方法
 死锁的产生满足上述的四个必要条件，只需要破坏其中一个或多个条件，死锁就不会产生。

**1.破坏请求保持条件**
在系统运行的时候，规定进程运行之前，一次性申请所有需要的资源，这时如果进程已经运行了，那么她就不需要再去请求资源，不可能因为再申请新的资源而产生等待的情况。

**2.破坏不可剥夺条件**
当一个进程请求新的资源得不到满足的时候，此进程必须释放当前占有的所有的资源。进程运行时占有的资源都可以被释放，即可以被剥夺。 

**3.破坏环路等待条件**
把可用资源按照线性进行排序，进程需要申请的时候按照需要递增的去申请，线性申请就不再产生环路。
假如资源进行排序如A-B-C-D，如果有一个进程需要使用AD资源的时候，必须先申请A，申请到A后才能去申请D。

 ## 银行家算法
 它是以银行借贷系统分配策略为基础的算法，是一个著名的可避免死锁的方法。
 假设客户申请的贷款是有限的，并且每次申请的时候都声明他需要申请的最大资金量。银行家在能够满足贷款时，都应该贷款给客户。同时客户使用完贷款后，能够及时归还给贷款。

这一算法要求有三个数据结构，分别是**已分配资源表**、**所需资源表**和**可分配资源表**。
通过所需资源-已分配资源=还需分配资源。将可分配资源与还需分配资源进行对比，如果满足就分配给这一进程，进程使用完后及时归还，再重新分配资源给其他进程继续执行。